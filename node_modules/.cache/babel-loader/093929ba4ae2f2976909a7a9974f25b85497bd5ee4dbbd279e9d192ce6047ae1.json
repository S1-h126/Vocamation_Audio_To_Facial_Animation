{"ast":null,"code":"import { AnimationClip, AnimationMixer, Euler, Matrix4, Quaternion, QuaternionKeyframeTrack, SkeletonHelper, Vector2, Vector3, VectorKeyframeTrack } from '../../../build/three.module.js';\nvar SkeletonUtils = {\n  retarget: function () {\n    var pos = new Vector3(),\n      quat = new Quaternion(),\n      scale = new Vector3(),\n      bindBoneMatrix = new Matrix4(),\n      relativeMatrix = new Matrix4(),\n      globalMatrix = new Matrix4();\n    return function (target, source, options) {\n      options = options || {};\n      options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n      options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n      options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n      options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n      var sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n        bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n        bindBones,\n        bone,\n        name,\n        boneTo,\n        bonesPosition,\n        i;\n\n      // reset bones\n\n      if (target.isObject3D) {\n        target.skeleton.pose();\n      } else {\n        options.useTargetMatrix = true;\n        options.preserveMatrix = false;\n      }\n      if (options.preservePosition) {\n        bonesPosition = [];\n        for (i = 0; i < bones.length; i++) {\n          bonesPosition.push(bones[i].position.clone());\n        }\n      }\n      if (options.preserveMatrix) {\n        // reset matrix\n\n        target.updateMatrixWorld();\n        target.matrixWorld.identity();\n\n        // reset children matrix\n\n        for (i = 0; i < target.children.length; ++i) {\n          target.children[i].updateMatrixWorld(true);\n        }\n      }\n      if (options.offsets) {\n        bindBones = [];\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n          if (options.offsets && options.offsets[name]) {\n            bone.matrix.multiply(options.offsets[name]);\n            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n            bone.updateMatrixWorld();\n          }\n          bindBones.push(bone.matrixWorld.clone());\n        }\n      }\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n        globalMatrix.copy(bone.matrixWorld);\n        if (boneTo) {\n          boneTo.updateMatrixWorld();\n          if (options.useTargetMatrix) {\n            relativeMatrix.copy(boneTo.matrixWorld);\n          } else {\n            relativeMatrix.copy(target.matrixWorld).invert();\n            relativeMatrix.multiply(boneTo.matrixWorld);\n          }\n\n          // ignore scale to extract rotation\n\n          scale.setFromMatrixScale(relativeMatrix);\n          relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));\n\n          // apply to global matrix\n\n          globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n          if (target.isObject3D) {\n            var boneIndex = bones.indexOf(bone),\n              wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n            globalMatrix.multiply(wBindMatrix);\n          }\n          globalMatrix.copyPosition(relativeMatrix);\n        }\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\n          bone.matrix.multiply(globalMatrix);\n        } else {\n          bone.matrix.copy(globalMatrix);\n        }\n        if (options.preserveHipPosition && name === options.hip) {\n          bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n        }\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n      if (options.preservePosition) {\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n          if (name !== options.hip) {\n            bone.position.copy(bonesPosition[i]);\n          }\n        }\n      }\n      if (options.preserveMatrix) {\n        // restore matrix\n\n        target.updateMatrixWorld(true);\n      }\n    };\n  }(),\n  retargetClip: function (target, source, clip, options) {\n    options = options || {};\n    options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n    options.fps = options.fps !== undefined ? options.fps : 30;\n    options.names = options.names || [];\n    if (!source.isObject3D) {\n      source = this.getHelperFromSkeleton(source);\n    }\n    var numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n      delta = 1 / options.fps,\n      convertedTracks = [],\n      mixer = new AnimationMixer(source),\n      bones = this.getBones(target.skeleton),\n      boneDatas = [],\n      positionOffset,\n      bone,\n      boneTo,\n      boneData,\n      name,\n      i,\n      j;\n    mixer.clipAction(clip).play();\n    mixer.update(0);\n    source.updateMatrixWorld();\n    for (i = 0; i < numFrames; ++i) {\n      var time = i * delta;\n      this.retarget(target, source, options);\n      for (j = 0; j < bones.length; ++j) {\n        name = options.names[bones[j].name] || bones[j].name;\n        boneTo = this.getBoneByName(name, source.skeleton);\n        if (boneTo) {\n          bone = bones[j];\n          boneData = boneDatas[j] = boneDatas[j] || {\n            bone: bone\n          };\n          if (options.hip === name) {\n            if (!boneData.pos) {\n              boneData.pos = {\n                times: new Float32Array(numFrames),\n                values: new Float32Array(numFrames * 3)\n              };\n            }\n            if (options.useFirstFramePosition) {\n              if (i === 0) {\n                positionOffset = bone.position.clone();\n              }\n              bone.position.sub(positionOffset);\n            }\n            boneData.pos.times[i] = time;\n            bone.position.toArray(boneData.pos.values, i * 3);\n          }\n          if (!boneData.quat) {\n            boneData.quat = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 4)\n            };\n          }\n          boneData.quat.times[i] = time;\n          bone.quaternion.toArray(boneData.quat.values, i * 4);\n        }\n      }\n      mixer.update(delta);\n      source.updateMatrixWorld();\n    }\n    for (i = 0; i < boneDatas.length; ++i) {\n      boneData = boneDatas[i];\n      if (boneData) {\n        if (boneData.pos) {\n          convertedTracks.push(new VectorKeyframeTrack('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));\n        }\n        convertedTracks.push(new QuaternionKeyframeTrack('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));\n      }\n    }\n    mixer.uncacheAction(clip);\n    return new AnimationClip(clip.name, -1, convertedTracks);\n  },\n  getHelperFromSkeleton: function (skeleton) {\n    var source = new SkeletonHelper(skeleton.bones[0]);\n    source.skeleton = skeleton;\n    return source;\n  },\n  getSkeletonOffsets: function () {\n    var targetParentPos = new Vector3(),\n      targetPos = new Vector3(),\n      sourceParentPos = new Vector3(),\n      sourcePos = new Vector3(),\n      targetDir = new Vector2(),\n      sourceDir = new Vector2();\n    return function (target, source, options) {\n      options = options || {};\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n      if (!source.isObject3D) {\n        source = this.getHelperFromSkeleton(source);\n      }\n      var nameKeys = Object.keys(options.names),\n        nameValues = Object.values(options.names),\n        sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n        bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n        offsets = [],\n        bone,\n        boneTo,\n        name,\n        i;\n      target.skeleton.pose();\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n        if (boneTo && name !== options.hip) {\n          var boneParent = this.getNearestBone(bone.parent, nameKeys),\n            boneToParent = this.getNearestBone(boneTo.parent, nameValues);\n          boneParent.updateMatrixWorld();\n          boneToParent.updateMatrixWorld();\n          targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);\n          targetPos.setFromMatrixPosition(bone.matrixWorld);\n          sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);\n          sourcePos.setFromMatrixPosition(boneTo.matrixWorld);\n          targetDir.subVectors(new Vector2(targetPos.x, targetPos.y), new Vector2(targetParentPos.x, targetParentPos.y)).normalize();\n          sourceDir.subVectors(new Vector2(sourcePos.x, sourcePos.y), new Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();\n          var laterialAngle = targetDir.angle() - sourceDir.angle();\n          var offset = new Matrix4().makeRotationFromEuler(new Euler(0, 0, laterialAngle));\n          bone.matrix.multiply(offset);\n          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n          bone.updateMatrixWorld();\n          offsets[name] = offset;\n        }\n      }\n      return offsets;\n    };\n  }(),\n  renameBones: function (skeleton, names) {\n    var bones = this.getBones(skeleton);\n    for (var i = 0; i < bones.length; ++i) {\n      var bone = bones[i];\n      if (names[bone.name]) {\n        bone.name = names[bone.name];\n      }\n    }\n    return this;\n  },\n  getBones: function (skeleton) {\n    return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n  },\n  getBoneByName: function (name, skeleton) {\n    for (var i = 0, bones = this.getBones(skeleton); i < bones.length; i++) {\n      if (name === bones[i].name) return bones[i];\n    }\n  },\n  getNearestBone: function (bone, names) {\n    while (bone.isBone) {\n      if (names.indexOf(bone.name) !== -1) {\n        return bone;\n      }\n      bone = bone.parent;\n    }\n  },\n  findBoneTrackData: function (name, tracks) {\n    var regexp = /\\[(.*)\\]\\.(.*)/,\n      result = {\n        name: name\n      };\n    for (var i = 0; i < tracks.length; ++i) {\n      // 1 is track name\n      // 2 is track type\n      var trackData = regexp.exec(tracks[i].name);\n      if (trackData && name === trackData[1]) {\n        result[trackData[2]] = i;\n      }\n    }\n    return result;\n  },\n  getEqualsBonesNames: function (skeleton, targetSkeleton) {\n    var sourceBones = this.getBones(skeleton),\n      targetBones = this.getBones(targetSkeleton),\n      bones = [];\n    search: for (var i = 0; i < sourceBones.length; i++) {\n      var boneName = sourceBones[i].name;\n      for (var j = 0; j < targetBones.length; j++) {\n        if (boneName === targetBones[j].name) {\n          bones.push(boneName);\n          continue search;\n        }\n      }\n    }\n    return bones;\n  },\n  clone: function (source) {\n    var sourceLookup = new Map();\n    var cloneLookup = new Map();\n    var clone = source.clone();\n    parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n      sourceLookup.set(clonedNode, sourceNode);\n      cloneLookup.set(sourceNode, clonedNode);\n    });\n    clone.traverse(function (node) {\n      if (!node.isSkinnedMesh) return;\n      var clonedMesh = node;\n      var sourceMesh = sourceLookup.get(node);\n      var sourceBones = sourceMesh.skeleton.bones;\n      clonedMesh.skeleton = sourceMesh.skeleton.clone();\n      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n      clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n        return cloneLookup.get(bone);\n      });\n      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n    });\n    return clone;\n  }\n};\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n  for (var i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\nexport { SkeletonUtils };","map":{"version":3,"names":["AnimationClip","AnimationMixer","Euler","Matrix4","Quaternion","QuaternionKeyframeTrack","SkeletonHelper","Vector2","Vector3","VectorKeyframeTrack","SkeletonUtils","retarget","pos","quat","scale","bindBoneMatrix","relativeMatrix","globalMatrix","target","source","options","preserveMatrix","undefined","preservePosition","preserveHipPosition","useTargetMatrix","hip","names","sourceBones","isObject3D","skeleton","bones","getBones","bindBones","bone","name","boneTo","bonesPosition","i","pose","length","push","position","clone","updateMatrixWorld","matrixWorld","identity","children","offsets","matrix","multiply","decompose","quaternion","getBoneByName","copy","invert","setFromMatrixScale","set","x","y","z","makeRotationFromQuaternion","setFromRotationMatrix","boneIndex","indexOf","wBindMatrix","boneInverses","copyPosition","parent","isBone","setPosition","retargetClip","clip","useFirstFramePosition","fps","getHelperFromSkeleton","numFrames","Math","round","duration","delta","convertedTracks","mixer","boneDatas","positionOffset","boneData","j","clipAction","play","update","time","times","Float32Array","values","sub","toArray","uncacheAction","getSkeletonOffsets","targetParentPos","targetPos","sourceParentPos","sourcePos","targetDir","sourceDir","nameKeys","Object","keys","nameValues","boneParent","getNearestBone","boneToParent","setFromMatrixPosition","subVectors","normalize","laterialAngle","angle","offset","makeRotationFromEuler","renameBones","Array","isArray","findBoneTrackData","tracks","regexp","result","trackData","exec","getEqualsBonesNames","targetSkeleton","targetBones","search","boneName","sourceLookup","Map","cloneLookup","parallelTraverse","sourceNode","clonedNode","traverse","node","isSkinnedMesh","clonedMesh","sourceMesh","get","bindMatrix","map","bind","a","b","callback"],"sources":["C:/facial-animation/node_modules/three/examples/jsm/utils/SkeletonUtils.js"],"sourcesContent":["import {\n\tAnimationClip,\n\tAnimationMixer,\n\tEuler,\n\tMatrix4,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tSkeletonHelper,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack\n} from '../../../build/three.module.js';\n\nvar SkeletonUtils = {\n\n\tretarget: function () {\n\n\t\tvar pos = new Vector3(),\n\t\t\tquat = new Quaternion(),\n\t\t\tscale = new Vector3(),\n\t\t\tbindBoneMatrix = new Matrix4(),\n\t\t\trelativeMatrix = new Matrix4(),\n\t\t\tglobalMatrix = new Matrix4();\n\n\t\treturn function ( target, source, options ) {\n\n\t\t\toptions = options || {};\n\t\t\toptions.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n\t\t\toptions.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n\t\t\toptions.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n\t\t\toptions.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n\t\t\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\t\t\toptions.names = options.names || {};\n\n\t\t\tvar sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones( source ),\n\t\t\t\tbones = target.isObject3D ? target.skeleton.bones : this.getBones( target ),\n\t\t\t\tbindBones,\n\t\t\t\tbone, name, boneTo,\n\t\t\t\tbonesPosition, i;\n\n\t\t\t// reset bones\n\n\t\t\tif ( target.isObject3D ) {\n\n\t\t\t\ttarget.skeleton.pose();\n\n\t\t\t} else {\n\n\t\t\t\toptions.useTargetMatrix = true;\n\t\t\t\toptions.preserveMatrix = false;\n\n\t\t\t}\n\n\t\t\tif ( options.preservePosition ) {\n\n\t\t\t\tbonesPosition = [];\n\n\t\t\t\tfor ( i = 0; i < bones.length; i ++ ) {\n\n\t\t\t\t\tbonesPosition.push( bones[ i ].position.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.preserveMatrix ) {\n\n\t\t\t\t// reset matrix\n\n\t\t\t\ttarget.updateMatrixWorld();\n\n\t\t\t\ttarget.matrixWorld.identity();\n\n\t\t\t\t// reset children matrix\n\n\t\t\t\tfor ( i = 0; i < target.children.length; ++ i ) {\n\n\t\t\t\t\ttarget.children[ i ].updateMatrixWorld( true );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.offsets ) {\n\n\t\t\t\tbindBones = [];\n\n\t\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\n\n\t\t\t\t\tbone = bones[ i ];\n\t\t\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\t\t\tif ( options.offsets && options.offsets[ name ] ) {\n\n\t\t\t\t\t\tbone.matrix.multiply( options.offsets[ name ] );\n\n\t\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\t\t\tbone.updateMatrixWorld();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindBones.push( bone.matrixWorld.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\n\n\t\t\t\tbone = bones[ i ];\n\t\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\t\tboneTo = this.getBoneByName( name, sourceBones );\n\n\t\t\t\tglobalMatrix.copy( bone.matrixWorld );\n\n\t\t\t\tif ( boneTo ) {\n\n\t\t\t\t\tboneTo.updateMatrixWorld();\n\n\t\t\t\t\tif ( options.useTargetMatrix ) {\n\n\t\t\t\t\t\trelativeMatrix.copy( boneTo.matrixWorld );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\trelativeMatrix.copy( target.matrixWorld ).invert();\n\t\t\t\t\t\trelativeMatrix.multiply( boneTo.matrixWorld );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// ignore scale to extract rotation\n\n\t\t\t\t\tscale.setFromMatrixScale( relativeMatrix );\n\t\t\t\t\trelativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );\n\n\t\t\t\t\t// apply to global matrix\n\n\t\t\t\t\tglobalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );\n\n\t\t\t\t\tif ( target.isObject3D ) {\n\n\t\t\t\t\t\tvar boneIndex = bones.indexOf( bone ),\n\t\t\t\t\t\t\twBindMatrix = bindBones ? bindBones[ boneIndex ] : bindBoneMatrix.copy( target.skeleton.boneInverses[ boneIndex ] ).invert();\n\n\t\t\t\t\t\tglobalMatrix.multiply( wBindMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tglobalMatrix.copyPosition( relativeMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\t\t\tbone.matrix.multiply( globalMatrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( globalMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tif ( options.preserveHipPosition && name === options.hip ) {\n\n\t\t\t\t\tbone.matrix.setPosition( pos.set( 0, bone.position.y, 0 ) );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\tbone.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t\tif ( options.preservePosition ) {\n\n\t\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\n\n\t\t\t\t\tbone = bones[ i ];\n\t\t\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\t\t\tif ( name !== options.hip ) {\n\n\t\t\t\t\t\tbone.position.copy( bonesPosition[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.preserveMatrix ) {\n\n\t\t\t\t// restore matrix\n\n\t\t\t\ttarget.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\tretargetClip: function ( target, source, clip, options ) {\n\n\t\toptions = options || {};\n\t\toptions.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n\t\toptions.fps = options.fps !== undefined ? options.fps : 30;\n\t\toptions.names = options.names || [];\n\n\t\tif ( ! source.isObject3D ) {\n\n\t\t\tsource = this.getHelperFromSkeleton( source );\n\n\t\t}\n\n\t\tvar numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),\n\t\t\tdelta = 1 / options.fps,\n\t\t\tconvertedTracks = [],\n\t\t\tmixer = new AnimationMixer( source ),\n\t\t\tbones = this.getBones( target.skeleton ),\n\t\t\tboneDatas = [],\n\t\t\tpositionOffset,\n\t\t\tbone, boneTo, boneData,\n\t\t\tname, i, j;\n\n\t\tmixer.clipAction( clip ).play();\n\t\tmixer.update( 0 );\n\n\t\tsource.updateMatrixWorld();\n\n\t\tfor ( i = 0; i < numFrames; ++ i ) {\n\n\t\t\tvar time = i * delta;\n\n\t\t\tthis.retarget( target, source, options );\n\n\t\t\tfor ( j = 0; j < bones.length; ++ j ) {\n\n\t\t\t\tname = options.names[ bones[ j ].name ] || bones[ j ].name;\n\n\t\t\t\tboneTo = this.getBoneByName( name, source.skeleton );\n\n\t\t\t\tif ( boneTo ) {\n\n\t\t\t\t\tbone = bones[ j ];\n\t\t\t\t\tboneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };\n\n\t\t\t\t\tif ( options.hip === name ) {\n\n\t\t\t\t\t\tif ( ! boneData.pos ) {\n\n\t\t\t\t\t\t\tboneData.pos = {\n\t\t\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\t\t\tvalues: new Float32Array( numFrames * 3 )\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( options.useFirstFramePosition ) {\n\n\t\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\t\tpositionOffset = bone.position.clone();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbone.position.sub( positionOffset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tboneData.pos.times[ i ] = time;\n\n\t\t\t\t\t\tbone.position.toArray( boneData.pos.values, i * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! boneData.quat ) {\n\n\t\t\t\t\t\tboneData.quat = {\n\t\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\t\tvalues: new Float32Array( numFrames * 4 )\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.quat.times[ i ] = time;\n\n\t\t\t\t\tbone.quaternion.toArray( boneData.quat.values, i * 4 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmixer.update( delta );\n\n\t\t\tsource.updateMatrixWorld();\n\n\t\t}\n\n\t\tfor ( i = 0; i < boneDatas.length; ++ i ) {\n\n\t\t\tboneData = boneDatas[ i ];\n\n\t\t\tif ( boneData ) {\n\n\t\t\t\tif ( boneData.pos ) {\n\n\t\t\t\t\tconvertedTracks.push( new VectorKeyframeTrack(\n\t\t\t\t\t\t'.bones[' + boneData.bone.name + '].position',\n\t\t\t\t\t\tboneData.pos.times,\n\t\t\t\t\t\tboneData.pos.values\n\t\t\t\t\t) );\n\n\t\t\t\t}\n\n\t\t\t\tconvertedTracks.push( new QuaternionKeyframeTrack(\n\t\t\t\t\t'.bones[' + boneData.bone.name + '].quaternion',\n\t\t\t\t\tboneData.quat.times,\n\t\t\t\t\tboneData.quat.values\n\t\t\t\t) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tmixer.uncacheAction( clip );\n\n\t\treturn new AnimationClip( clip.name, - 1, convertedTracks );\n\n\t},\n\n\tgetHelperFromSkeleton: function ( skeleton ) {\n\n\t\tvar source = new SkeletonHelper( skeleton.bones[ 0 ] );\n\t\tsource.skeleton = skeleton;\n\n\t\treturn source;\n\n\t},\n\n\tgetSkeletonOffsets: function () {\n\n\t\tvar targetParentPos = new Vector3(),\n\t\t\ttargetPos = new Vector3(),\n\t\t\tsourceParentPos = new Vector3(),\n\t\t\tsourcePos = new Vector3(),\n\t\t\ttargetDir = new Vector2(),\n\t\t\tsourceDir = new Vector2();\n\n\t\treturn function ( target, source, options ) {\n\n\t\t\toptions = options || {};\n\t\t\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\t\t\toptions.names = options.names || {};\n\n\t\t\tif ( ! source.isObject3D ) {\n\n\t\t\t\tsource = this.getHelperFromSkeleton( source );\n\n\t\t\t}\n\n\t\t\tvar nameKeys = Object.keys( options.names ),\n\t\t\t\tnameValues = Object.values( options.names ),\n\t\t\t\tsourceBones = source.isObject3D ? source.skeleton.bones : this.getBones( source ),\n\t\t\t\tbones = target.isObject3D ? target.skeleton.bones : this.getBones( target ),\n\t\t\t\toffsets = [],\n\t\t\t\tbone, boneTo,\n\t\t\t\tname, i;\n\n\t\t\ttarget.skeleton.pose();\n\n\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\n\n\t\t\t\tbone = bones[ i ];\n\t\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\t\tboneTo = this.getBoneByName( name, sourceBones );\n\n\t\t\t\tif ( boneTo && name !== options.hip ) {\n\n\t\t\t\t\tvar boneParent = this.getNearestBone( bone.parent, nameKeys ),\n\t\t\t\t\t\tboneToParent = this.getNearestBone( boneTo.parent, nameValues );\n\n\t\t\t\t\tboneParent.updateMatrixWorld();\n\t\t\t\t\tboneToParent.updateMatrixWorld();\n\n\t\t\t\t\ttargetParentPos.setFromMatrixPosition( boneParent.matrixWorld );\n\t\t\t\t\ttargetPos.setFromMatrixPosition( bone.matrixWorld );\n\n\t\t\t\t\tsourceParentPos.setFromMatrixPosition( boneToParent.matrixWorld );\n\t\t\t\t\tsourcePos.setFromMatrixPosition( boneTo.matrixWorld );\n\n\t\t\t\t\ttargetDir.subVectors(\n\t\t\t\t\t\tnew Vector2( targetPos.x, targetPos.y ),\n\t\t\t\t\t\tnew Vector2( targetParentPos.x, targetParentPos.y )\n\t\t\t\t\t).normalize();\n\n\t\t\t\t\tsourceDir.subVectors(\n\t\t\t\t\t\tnew Vector2( sourcePos.x, sourcePos.y ),\n\t\t\t\t\t\tnew Vector2( sourceParentPos.x, sourceParentPos.y )\n\t\t\t\t\t).normalize();\n\n\t\t\t\t\tvar laterialAngle = targetDir.angle() - sourceDir.angle();\n\n\t\t\t\t\tvar offset = new Matrix4().makeRotationFromEuler(\n\t\t\t\t\t\tnew Euler(\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tlaterialAngle\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\tbone.matrix.multiply( offset );\n\n\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\t\tbone.updateMatrixWorld();\n\n\t\t\t\t\toffsets[ name ] = offset;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn offsets;\n\n\t\t};\n\n\t}(),\n\n\trenameBones: function ( skeleton, names ) {\n\n\t\tvar bones = this.getBones( skeleton );\n\n\t\tfor ( var i = 0; i < bones.length; ++ i ) {\n\n\t\t\tvar bone = bones[ i ];\n\n\t\t\tif ( names[ bone.name ] ) {\n\n\t\t\t\tbone.name = names[ bone.name ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetBones: function ( skeleton ) {\n\n\t\treturn Array.isArray( skeleton ) ? skeleton : skeleton.bones;\n\n\t},\n\n\tgetBoneByName: function ( name, skeleton ) {\n\n\t\tfor ( var i = 0, bones = this.getBones( skeleton ); i < bones.length; i ++ ) {\n\n\t\t\tif ( name === bones[ i ].name )\n\n\t\t\t\treturn bones[ i ];\n\n\t\t}\n\n\t},\n\n\tgetNearestBone: function ( bone, names ) {\n\n\t\twhile ( bone.isBone ) {\n\n\t\t\tif ( names.indexOf( bone.name ) !== - 1 ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t\tbone = bone.parent;\n\n\t\t}\n\n\t},\n\n\tfindBoneTrackData: function ( name, tracks ) {\n\n\t\tvar regexp = /\\[(.*)\\]\\.(.*)/,\n\t\t\tresult = { name: name };\n\n\t\tfor ( var i = 0; i < tracks.length; ++ i ) {\n\n\t\t\t// 1 is track name\n\t\t\t// 2 is track type\n\t\t\tvar trackData = regexp.exec( tracks[ i ].name );\n\n\t\t\tif ( trackData && name === trackData[ 1 ] ) {\n\n\t\t\t\tresult[ trackData[ 2 ] ] = i;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\tgetEqualsBonesNames: function ( skeleton, targetSkeleton ) {\n\n\t\tvar sourceBones = this.getBones( skeleton ),\n\t\t\ttargetBones = this.getBones( targetSkeleton ),\n\t\t\tbones = [];\n\n\t\tsearch : for ( var i = 0; i < sourceBones.length; i ++ ) {\n\n\t\t\tvar boneName = sourceBones[ i ].name;\n\n\t\t\tfor ( var j = 0; j < targetBones.length; j ++ ) {\n\n\t\t\t\tif ( boneName === targetBones[ j ].name ) {\n\n\t\t\t\t\tbones.push( boneName );\n\n\t\t\t\t\tcontinue search;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bones;\n\n\t},\n\n\tclone: function ( source ) {\n\n\t\tvar sourceLookup = new Map();\n\t\tvar cloneLookup = new Map();\n\n\t\tvar clone = source.clone();\n\n\t\tparallelTraverse( source, clone, function ( sourceNode, clonedNode ) {\n\n\t\t\tsourceLookup.set( clonedNode, sourceNode );\n\t\t\tcloneLookup.set( sourceNode, clonedNode );\n\n\t\t} );\n\n\t\tclone.traverse( function ( node ) {\n\n\t\t\tif ( ! node.isSkinnedMesh ) return;\n\n\t\t\tvar clonedMesh = node;\n\t\t\tvar sourceMesh = sourceLookup.get( node );\n\t\t\tvar sourceBones = sourceMesh.skeleton.bones;\n\n\t\t\tclonedMesh.skeleton = sourceMesh.skeleton.clone();\n\t\t\tclonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );\n\n\t\t\tclonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {\n\n\t\t\t\treturn cloneLookup.get( bone );\n\n\t\t\t} );\n\n\t\t\tclonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );\n\n\t\t} );\n\n\t\treturn clone;\n\n\t}\n\n};\n\n\nfunction parallelTraverse( a, b, callback ) {\n\n\tcallback( a, b );\n\n\tfor ( var i = 0; i < a.children.length; i ++ ) {\n\n\t\tparallelTraverse( a.children[ i ], b.children[ i ], callback );\n\n\t}\n\n}\n\nexport { SkeletonUtils };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}